# Visionairy App - Convex Backend Implementation Guide

## Overview
This guide provides detailed, step-by-step instructions for implementing the Convex backend for the Visionairy app. Each feature is implemented as a **vertical slice** - meaning all layers (database, backend functions, and frontend integration) are completed together to ensure functionality at each step.

## Available Tools
Throughout this implementation, you have access to Convex MCP tools for debugging and testing:
- `mcp_convex_status` - Get deployment information
- `mcp_convex_data` - Read table data
- `mcp_convex_tables` - List all tables and schemas
- `mcp_convex_functionSpec` - Get function metadata
- `mcp_convex_run` - Execute functions directly
- `mcp_convex_envList/envGet/envSet` - Manage environment variables

---

## Phase 0: Foundation & Setup

### Prerequisites
- Node.js 18+ installed
- npm or bun package manager
- OpenAI API key for image generation

### Step 1: Install Convex Dependencies

```bash
# Install core Convex packages
npm install convex @convex-dev/auth

# Install additional dependencies
npm install --save-dev @types/node
```

### Step 2: Initialize Convex Project

```bash
# Initialize Convex (creates convex/ directory and _generated files)
npx convex dev

# This will:
# 1. Create a new Convex project (if not exists)
# 2. Generate convex/_generated/ folder with TypeScript types
# 3. Start watching for changes
# Keep this running in a terminal
```

### Step 3: Environment Setup

```bash
# Set required environment variables for development
npx convex env set SITE_URL http://localhost:5173
npx convex env set OPENAI_API_KEY your_openai_api_key_here

# Optional: Set JWT secret for enhanced security
npx convex env set JWT_PRIVATE_KEY "$(openssl ecparam -name secp256k1 -genkey -noout | openssl ec -outform DER | tail -c +8 | head -c 32 | xxd -p -c 32)"
```

### Step 4: Update Vite Configuration

Update `vite.config.ts` to ensure proper environment variable handling:

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'

export default defineConfig({
  plugins: [react()],
  define: {
    'process.env': process.env
  }
})
```

### Step 5: Create Base Convex Structure

Create the following file structure:
```
convex/
  ├── _generated/       # Auto-generated by Convex
  ├── schema.ts        # Database schema
  ├── auth.ts          # Authentication configuration
  ├── http.ts          # HTTP routes
  └── lib/             # Shared utilities
      └── constants.ts
```

---

## Feature 0: Authentication System

### Step 1: Define User Schema

Create `convex/schema.ts`:

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import { authTables } from "@convex-dev/auth/server";

export default defineSchema({
  ...authTables,
  
  // Extended user profile
  users: defineTable({
    // Auth fields (managed by Convex Auth)
    email: v.optional(v.string()),
    emailVerificationTime: v.optional(v.number()),
    image: v.optional(v.string()),
    isAnonymous: v.optional(v.boolean()),
    name: v.optional(v.string()),
    
    // Custom fields
    username: v.optional(v.string()),
    displayName: v.optional(v.string()),
    avatarId: v.optional(v.id("_storage")),
    lastActiveAt: v.optional(v.number()),
    onboardingCompleted: v.optional(v.boolean()),
    
    // Game stats
    gamesPlayed: v.optional(v.number()),
    gamesWon: v.optional(v.number()),
    totalScore: v.optional(v.number()),
  })
    .index("by_email", ["email"])
    .index("by_username", ["username"]),
});
```

### Step 2: Configure Authentication

Create `convex/auth.ts`:

```typescript
import { convexAuth } from "@convex-dev/auth/server";
import { Password } from "@convex-dev/auth/providers/Password";
import { Anonymous } from "@convex-dev/auth/providers/Anonymous";

export const { auth, signIn, signOut, store, isAuthenticated } = convexAuth({
  providers: [
    // Password authentication with email
    Password({
      // Custom password validation
      validatePasswordRequirements: (password: string) => {
        if (password.length < 8) {
          throw new Error("Password must be at least 8 characters");
        }
        if (!/\d/.test(password) || !/[a-zA-Z]/.test(password)) {
          throw new Error("Password must contain letters and numbers");
        }
      },
      
      // Custom profile handling
      profile(params) {
        return {
          email: params.email as string,
          name: params.name as string,
        };
      },
    }),
    
    // Anonymous authentication for guests
    Anonymous,
  ],
  
  callbacks: {
    async createOrUpdateUser(ctx, args) {
      // Check if user exists
      const existingUser = args.existingUserId 
        ? await ctx.db.get(args.existingUserId)
        : null;
        
      if (existingUser) {
        // Update last active timestamp
        await ctx.db.patch(existingUser._id, {
          lastActiveAt: Date.now(),
        });
        return existingUser._id;
      }
      
      // Create new user
      return await ctx.db.insert("users", {
        ...args.profile,
        lastActiveAt: Date.now(),
        onboardingCompleted: false,
        gamesPlayed: 0,
        gamesWon: 0,
        totalScore: 0,
      });
    },
  },
});
```

### Step 3: Create HTTP Routes

Create `convex/http.ts`:

```typescript
import { httpRouter } from "convex/server";
import { auth } from "./auth";

const http = httpRouter();

// Add authentication routes
auth.addHttpRoutes(http);

// Health check endpoint
http.route({
  path: "/health",
  method: "GET",
  handler: httpAction(async () => {
    return new Response("OK", { status: 200 });
  }),
});

export default http;
```

### Step 4: Create User Management Functions

Create `convex/users.ts`:

```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

// Get current user
export const getCurrentUser = query({
  args: {},
  returns: v.union(
    v.null(),
    v.object({
      _id: v.id("users"),
      email: v.optional(v.string()),
      username: v.optional(v.string()),
      displayName: v.optional(v.string()),
      avatarId: v.optional(v.id("_storage")),
      onboardingCompleted: v.optional(v.boolean()),
      gamesPlayed: v.optional(v.number()),
      gamesWon: v.optional(v.number()),
    })
  ),
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;
    
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
      
    return user;
  },
});

// Update username (onboarding)
export const updateUsername = mutation({
  args: {
    username: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");
    
    // Validate username
    if (args.username.length < 3 || args.username.length > 20) {
      throw new Error("Username must be 3-20 characters");
    }
    
    if (!/^[a-zA-Z0-9_]+$/.test(args.username)) {
      throw new Error("Username can only contain letters, numbers, and underscores");
    }
    
    // Check if username is taken
    const existing = await ctx.db
      .query("users")
      .withIndex("by_username", (q) => q.eq("username", args.username))
      .unique();
      
    if (existing) {
      throw new Error("Username already taken");
    }
    
    // Update user
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
      
    if (!user) throw new Error("User not found");
    
    await ctx.db.patch(user._id, {
      username: args.username,
      displayName: args.username,
      onboardingCompleted: true,
    });
    
    return null;
  },
});
```

### Step 5: Frontend Integration

Update `src/main.tsx`:

```tsx
import { ConvexAuthProvider } from "@convex-dev/auth/react";
import React from "react";
import ReactDOM from "react-dom/client";
import { ConvexReactClient } from "convex/react";
import App from "./App.tsx";
import "./index.css";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ConvexAuthProvider client={convex}>
      <App />
    </ConvexAuthProvider>
  </React.StrictMode>,
);
```

Update authentication components in `src/components/auth/`:

```tsx
// src/hooks/use-auth.ts
import { useAuthActions } from "@convex-dev/auth/react";
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

export function useAuth() {
  const { signIn, signOut } = useAuthActions();
  const user = useQuery(api.users.getCurrentUser);
  
  return {
    user,
    signIn,
    signOut,
    isAuthenticated: !!user,
    isLoading: user === undefined,
  };
}

// Update Login.tsx to use Convex Auth
import { useAuthActions } from "@convex-dev/auth/react";

export function Login() {
  const { signIn } = useAuthActions();
  
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    await signIn("password", formData);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="email" type="email" required />
      <input name="password" type="password" required />
      <input name="flow" type="hidden" value="signIn" />
      <button type="submit">Sign In</button>
    </form>
  );
}
```

---

## Feature 1: Room Management System

### Step 1: Extend Schema for Rooms

Update `convex/schema.ts`:

```typescript
// Add to existing schema
export default defineSchema({
  // ... existing tables ...
  
  rooms: defineTable({
    code: v.string(),
    name: v.string(),
    hostId: v.id("users"),
    status: v.union(
      v.literal("waiting"),
      v.literal("starting"),
      v.literal("playing"),
      v.literal("finished")
    ),
    settings: v.object({
      maxPlayers: v.number(),
      roundsPerGame: v.number(),
      timePerRound: v.number(),
      isPrivate: v.boolean(),
      allowLateJoin: v.boolean(),
    }),
    currentRound: v.optional(v.number()),
    createdAt: v.number(),
    startedAt: v.optional(v.number()),
    finishedAt: v.optional(v.number()),
  })
    .index("by_code", ["code"])
    .index("by_status", ["status"])
    .index("by_host", ["hostId"]),
  
  players: defineTable({
    roomId: v.id("rooms"),
    userId: v.id("users"),
    status: v.union(
      v.literal("connected"),
      v.literal("disconnected"),
      v.literal("kicked")
    ),
    isHost: v.boolean(),
    score: v.number(),
    joinedAt: v.number(),
    lastSeenAt: v.number(),
  })
    .index("by_room", ["roomId"])
    .index("by_user", ["userId"])
    .index("by_room_and_user", ["roomId", "userId"]),
});
```

### Step 2: Room Management Functions

Create `convex/rooms.ts`:

```typescript
import { query, mutation, internalMutation } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";

// Generate unique room code
function generateRoomCode(): string {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let code = "";
  for (let i = 0; i < 6; i++) {
    code += chars[Math.floor(Math.random() * chars.length)];
  }
  return code;
}

// Create a new room
export const createRoom = mutation({
  args: {
    name: v.string(),
    settings: v.optional(v.object({
      maxPlayers: v.optional(v.number()),
      roundsPerGame: v.optional(v.number()),
      timePerRound: v.optional(v.number()),
      isPrivate: v.optional(v.boolean()),
    })),
  },
  returns: v.object({
    roomId: v.id("rooms"),
    code: v.string(),
  }),
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");
    
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
    if (!user) throw new Error("User not found");
    
    // Generate unique code
    let code: string;
    let attempts = 0;
    do {
      code = generateRoomCode();
      const existing = await ctx.db
        .query("rooms")
        .withIndex("by_code", (q) => q.eq("code", code))
        .unique();
      if (!existing) break;
      attempts++;
    } while (attempts < 10);
    
    // Create room
    const roomId = await ctx.db.insert("rooms", {
      code,
      name: args.name,
      hostId: user._id,
      status: "waiting",
      settings: {
        maxPlayers: args.settings?.maxPlayers ?? 8,
        roundsPerGame: args.settings?.roundsPerGame ?? 5,
        timePerRound: args.settings?.timePerRound ?? 90,
        isPrivate: args.settings?.isPrivate ?? false,
        allowLateJoin: true,
      },
      createdAt: Date.now(),
    });
    
    // Add host as first player
    await ctx.db.insert("players", {
      roomId,
      userId: user._id,
      status: "connected",
      isHost: true,
      score: 0,
      joinedAt: Date.now(),
      lastSeenAt: Date.now(),
    });
    
    return { roomId, code };
  },
});

// Join a room by code
export const joinRoom = mutation({
  args: {
    code: v.string(),
  },
  returns: v.object({
    roomId: v.id("rooms"),
    success: v.boolean(),
  }),
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");
    
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
    if (!user) throw new Error("User not found");
    
    // Find room
    const room = await ctx.db
      .query("rooms")
      .withIndex("by_code", (q) => q.eq("code", args.code.toUpperCase()))
      .unique();
      
    if (!room) {
      throw new Error("Room not found");
    }
    
    if (room.status !== "waiting" && !room.settings.allowLateJoin) {
      throw new Error("Game already started");
    }
    
    // Check if already in room
    const existingPlayer = await ctx.db
      .query("players")
      .withIndex("by_room_and_user", (q) => 
        q.eq("roomId", room._id).eq("userId", user._id)
      )
      .unique();
      
    if (existingPlayer) {
      // Reconnect
      await ctx.db.patch(existingPlayer._id, {
        status: "connected",
        lastSeenAt: Date.now(),
      });
    } else {
      // Check room capacity
      const playerCount = await ctx.db
        .query("players")
        .withIndex("by_room", (q) => q.eq("roomId", room._id))
        .filter((q) => q.neq(q.field("status"), "kicked"))
        .collect();
        
      if (playerCount.length >= room.settings.maxPlayers) {
        throw new Error("Room is full");
      }
      
      // Add as new player
      await ctx.db.insert("players", {
        roomId: room._id,
        userId: user._id,
        status: "connected",
        isHost: false,
        score: 0,
        joinedAt: Date.now(),
        lastSeenAt: Date.now(),
      });
    }
    
    return { roomId: room._id, success: true };
  },
});

// Get room state (real-time subscription)
export const getRoomState = query({
  args: {
    roomId: v.id("rooms"),
  },
  returns: v.union(
    v.null(),
    v.object({
      room: v.object({
        _id: v.id("rooms"),
        code: v.string(),
        name: v.string(),
        status: v.string(),
        settings: v.object({
          maxPlayers: v.number(),
          roundsPerGame: v.number(),
          timePerRound: v.number(),
          isPrivate: v.boolean(),
          allowLateJoin: v.boolean(),
        }),
        currentRound: v.optional(v.number()),
      }),
      players: v.array(v.object({
        _id: v.id("players"),
        userId: v.id("users"),
        username: v.string(),
        displayName: v.string(),
        status: v.string(),
        isHost: v.boolean(),
        score: v.number(),
      })),
      isHost: v.boolean(),
    })
  ),
  handler: async (ctx, args) => {
    const room = await ctx.db.get(args.roomId);
    if (!room) return null;
    
    const identity = await ctx.auth.getUserIdentity();
    const currentUser = identity
      ? await ctx.db
          .query("users")
          .withIndex("by_email", (q) => q.eq("email", identity.email))
          .unique()
      : null;
    
    // Get all players with user info
    const players = await ctx.db
      .query("players")
      .withIndex("by_room", (q) => q.eq("roomId", args.roomId))
      .collect();
      
    const playersWithInfo = await Promise.all(
      players.map(async (player) => {
        const user = await ctx.db.get(player.userId);
        return {
          _id: player._id,
          userId: player.userId,
          username: user?.username ?? "Unknown",
          displayName: user?.displayName ?? user?.username ?? "Unknown",
          status: player.status,
          isHost: player.isHost,
          score: player.score,
        };
      })
    );
    
    return {
      room: {
        _id: room._id,
        code: room.code,
        name: room.name,
        status: room.status,
        settings: room.settings,
        currentRound: room.currentRound,
      },
      players: playersWithInfo,
      isHost: currentUser?._id === room.hostId,
    };
  },
});

// Start game
export const startGame = mutation({
  args: {
    roomId: v.id("rooms"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");
    
    const room = await ctx.db.get(args.roomId);
    if (!room) throw new Error("Room not found");
    
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
      
    if (user?._id !== room.hostId) {
      throw new Error("Only the host can start the game");
    }
    
    if (room.status !== "waiting") {
      throw new Error("Game already started");
    }
    
    // Update room status
    await ctx.db.patch(args.roomId, {
      status: "starting",
      startedAt: Date.now(),
      currentRound: 1,
    });
    
    // Schedule game initialization
    await ctx.scheduler.runAfter(0, internal.game.initializeGame, {
      roomId: args.roomId,
    });
    
    return null;
  },
});
```

### Step 3: Frontend Room Components

Update room-related components:

```tsx
// src/pages/Room.tsx
import { useParams, useNavigate } from "react-router-dom";
import { useQuery, useMutation } from "convex/react";
import { api } from "../convex/_generated/api";

export function Room() {
  const { roomId } = useParams<{ roomId: string }>();
  const navigate = useNavigate();
  
  const roomState = useQuery(api.rooms.getRoomState, {
    roomId: roomId as Id<"rooms">,
  });
  
  const startGame = useMutation(api.rooms.startGame);
  
  if (!roomState) {
    return <div>Loading room...</div>;
  }
  
  const handleStartGame = async () => {
    await startGame({ roomId: roomId as Id<"rooms"> });
    navigate(`/game/${roomId}`);
  };
  
  return (
    <div>
      <h1>{roomState.room.name}</h1>
      <p>Room Code: {roomState.room.code}</p>
      <p>Players: {roomState.players.length}/{roomState.room.settings.maxPlayers}</p>
      
      <div>
        {roomState.players.map((player) => (
          <div key={player._id}>
            {player.displayName} 
            {player.isHost && " (Host)"}
            {player.status === "disconnected" && " (Disconnected)"}
          </div>
        ))}
      </div>
      
      {roomState.isHost && roomState.room.status === "waiting" && (
        <button onClick={handleStartGame}>
          Start Game
        </button>
      )}
    </div>
  );
}
```

---

## Feature 2: Core Game Flow

### Step 1: Game Schema

Update `convex/schema.ts`:

```typescript
// Add game-related tables
export default defineSchema({
  // ... existing tables ...
  
  questionCards: defineTable({
    text: v.string(),
    category: v.optional(v.string()),
    difficulty: v.optional(v.number()),
    isActive: v.boolean(),
  })
    .index("by_active", ["isActive"]),
  
  rounds: defineTable({
    roomId: v.id("rooms"),
    roundNumber: v.number(),
    questionCardId: v.id("questionCards"),
    status: v.union(
      v.literal("prompt"),      // Players submitting prompts
      v.literal("generating"),  // AI generating images
      v.literal("voting"),      // Players voting
      v.literal("results"),     // Showing results
      v.literal("complete")     // Round finished
    ),
    startedAt: v.number(),
    endedAt: v.optional(v.number()),
    phaseEndTime: v.optional(v.number()),
  })
    .index("by_room", ["roomId"])
    .index("by_room_and_number", ["roomId", "roundNumber"]),
  
  prompts: defineTable({
    roundId: v.id("rounds"),
    playerId: v.id("players"),
    text: v.string(),
    submittedAt: v.number(),
  })
    .index("by_round", ["roundId"])
    .index("by_round_and_player", ["roundId", "playerId"]),
  
  generatedImages: defineTable({
    promptId: v.id("prompts"),
    imageUrl: v.string(),
    storageId: v.optional(v.id("_storage")),
    metadata: v.optional(v.object({
      model: v.string(),
      seed: v.optional(v.number()),
      revisedPrompt: v.optional(v.string()),
    })),
    generatedAt: v.number(),
    error: v.optional(v.string()),
  })
    .index("by_prompt", ["promptId"]),
  
  votes: defineTable({
    roundId: v.id("rounds"),
    voterId: v.id("players"),
    imageId: v.id("generatedImages"),
    submittedAt: v.number(),
  })
    .index("by_round", ["roundId"])
    .index("by_voter", ["voterId"])
    .index("by_image", ["imageId"])
    .index("by_round_and_voter", ["roundId", "voterId"]),
});
```

### Step 2: Game Logic Functions

Create `convex/game.ts`:

```typescript
"use node";

import { 
  query, 
  mutation, 
  internalMutation, 
  internalAction,
  action 
} from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";
import OpenAI from "openai";

// Initialize game after room starts
export const initializeGame = internalMutation({
  args: {
    roomId: v.id("rooms"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const room = await ctx.db.get(args.roomId);
    if (!room) throw new Error("Room not found");
    
    // Get random question card
    const questionCards = await ctx.db
      .query("questionCards")
      .withIndex("by_active", (q) => q.eq("isActive", true))
      .collect();
      
    if (questionCards.length === 0) {
      throw new Error("No question cards available");
    }
    
    const randomCard = questionCards[Math.floor(Math.random() * questionCards.length)];
    
    // Create first round
    const roundId = await ctx.db.insert("rounds", {
      roomId: args.roomId,
      roundNumber: 1,
      questionCardId: randomCard._id,
      status: "prompt",
      startedAt: Date.now(),
      phaseEndTime: Date.now() + 60000, // 60 seconds for prompts
    });
    
    // Update room status
    await ctx.db.patch(args.roomId, {
      status: "playing",
    });
    
    // Schedule phase transition
    await ctx.scheduler.runAt(Date.now() + 60000, internal.game.transitionPhase, {
      roundId,
    });
    
    return null;
  },
});

// Submit a prompt
export const submitPrompt = mutation({
  args: {
    roomId: v.id("rooms"),
    prompt: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");
    
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
    if (!user) throw new Error("User not found");
    
    // Get current round
    const room = await ctx.db.get(args.roomId);
    if (!room || !room.currentRound) {
      throw new Error("No active round");
    }
    
    const round = await ctx.db
      .query("rounds")
      .withIndex("by_room_and_number", (q) => 
        q.eq("roomId", args.roomId).eq("roundNumber", room.currentRound)
      )
      .unique();
      
    if (!round || round.status !== "prompt") {
      throw new Error("Not in prompt phase");
    }
    
    // Get player
    const player = await ctx.db
      .query("players")
      .withIndex("by_room_and_user", (q) =>
        q.eq("roomId", args.roomId).eq("userId", user._id)
      )
      .unique();
      
    if (!player) throw new Error("Player not in room");
    
    // Check if already submitted
    const existing = await ctx.db
      .query("prompts")
      .withIndex("by_round_and_player", (q) =>
        q.eq("roundId", round._id).eq("playerId", player._id)
      )
      .unique();
      
    if (existing) {
      // Update existing prompt
      await ctx.db.patch(existing._id, {
        text: args.prompt,
        submittedAt: Date.now(),
      });
    } else {
      // Create new prompt
      await ctx.db.insert("prompts", {
        roundId: round._id,
        playerId: player._id,
        text: args.prompt,
        submittedAt: Date.now(),
      });
    }
    
    return null;
  },
});

// Transition game phases
export const transitionPhase = internalMutation({
  args: {
    roundId: v.id("rounds"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const round = await ctx.db.get(args.roundId);
    if (!round) return null;
    
    switch (round.status) {
      case "prompt":
        // Move to generating phase
        await ctx.db.patch(args.roundId, {
          status: "generating",
          phaseEndTime: Date.now() + 30000, // 30 seconds for generation
        });
        
        // Trigger image generation
        await ctx.scheduler.runAfter(0, internal.game.generateImages, {
          roundId: args.roundId,
        });
        break;
        
      case "generating":
        // Move to voting phase
        await ctx.db.patch(args.roundId, {
          status: "voting",
          phaseEndTime: Date.now() + 45000, // 45 seconds for voting
        });
        
        // Schedule next transition
        await ctx.scheduler.runAt(Date.now() + 45000, internal.game.transitionPhase, {
          roundId: args.roundId,
        });
        break;
        
      case "voting":
        // Move to results phase
        await ctx.db.patch(args.roundId, {
          status: "results",
          phaseEndTime: Date.now() + 15000, // 15 seconds for results
        });
        
        // Calculate scores
        await ctx.scheduler.runAfter(0, internal.game.calculateScores, {
          roundId: args.roundId,
        });
        
        // Schedule next transition
        await ctx.scheduler.runAt(Date.now() + 15000, internal.game.transitionPhase, {
          roundId: args.roundId,
        });
        break;
        
      case "results":
        // Mark round as complete
        await ctx.db.patch(args.roundId, {
          status: "complete",
          endedAt: Date.now(),
        });
        
        // Start next round or end game
        const room = await ctx.db.get(round.roomId);
        if (room && room.currentRound && room.currentRound < room.settings.roundsPerGame) {
          // Start next round
          await ctx.scheduler.runAfter(2000, internal.game.startNextRound, {
            roomId: round.roomId,
          });
        } else {
          // End game
          await ctx.scheduler.runAfter(0, internal.game.endGame, {
            roomId: round.roomId,
          });
        }
        break;
    }
    
    return null;
  },
});

// Get current game state
export const getGameState = query({
  args: {
    roomId: v.id("rooms"),
  },
  returns: v.union(
    v.null(),
    v.object({
      room: v.object({
        status: v.string(),
        currentRound: v.optional(v.number()),
        totalRounds: v.number(),
      }),
      round: v.optional(v.object({
        _id: v.id("rounds"),
        status: v.string(),
        phaseEndTime: v.optional(v.number()),
        question: v.string(),
      })),
      players: v.array(v.object({
        _id: v.id("players"),
        displayName: v.string(),
        score: v.number(),
        hasSubmitted: v.boolean(),
      })),
      prompts: v.array(v.object({
        _id: v.id("prompts"),
        playerId: v.id("players"),
        text: v.string(),
      })),
      images: v.array(v.object({
        _id: v.id("generatedImages"),
        promptId: v.id("prompts"),
        imageUrl: v.string(),
        voteCount: v.number(),
      })),
      hasVoted: v.boolean(),
      myPrompt: v.optional(v.string()),
    })
  ),
  handler: async (ctx, args) => {
    const room = await ctx.db.get(args.roomId);
    if (!room) return null;
    
    const identity = await ctx.auth.getUserIdentity();
    const currentUser = identity
      ? await ctx.db
          .query("users")
          .withIndex("by_email", (q) => q.eq("email", identity.email))
          .unique()
      : null;
      
    const currentPlayer = currentUser
      ? await ctx.db
          .query("players")
          .withIndex("by_room_and_user", (q) =>
            q.eq("roomId", args.roomId).eq("userId", currentUser._id)
          )
          .unique()
      : null;
    
    // Get current round
    let round = null;
    let question = null;
    if (room.currentRound) {
      const roundData = await ctx.db
        .query("rounds")
        .withIndex("by_room_and_number", (q) =>
          q.eq("roomId", args.roomId).eq("roundNumber", room.currentRound)
        )
        .unique();
        
      if (roundData) {
        const card = await ctx.db.get(roundData.questionCardId);
        round = {
          _id: roundData._id,
          status: roundData.status,
          phaseEndTime: roundData.phaseEndTime,
          question: card?.text ?? "Unknown question",
        };
      }
    }
    
    // Get players with submission status
    const players = await ctx.db
      .query("players")
      .withIndex("by_room", (q) => q.eq("roomId", args.roomId))
      .collect();
      
    const playersWithInfo = await Promise.all(
      players.map(async (player) => {
        const user = await ctx.db.get(player.userId);
        const hasSubmitted = round
          ? !!(await ctx.db
              .query("prompts")
              .withIndex("by_round_and_player", (q) =>
                q.eq("roundId", round._id).eq("playerId", player._id)
              )
              .unique())
          : false;
          
        return {
          _id: player._id,
          displayName: user?.displayName ?? "Unknown",
          score: player.score,
          hasSubmitted,
        };
      })
    );
    
    // Get prompts and images for current round
    const prompts = round
      ? await ctx.db
          .query("prompts")
          .withIndex("by_round", (q) => q.eq("roundId", round._id))
          .collect()
      : [];
      
    const images = await Promise.all(
      prompts.map(async (prompt) => {
        const generatedImages = await ctx.db
          .query("generatedImages")
          .withIndex("by_prompt", (q) => q.eq("promptId", prompt._id))
          .collect();
          
        return generatedImages.map(async (img) => {
          const votes = await ctx.db
            .query("votes")
            .withIndex("by_image", (q) => q.eq("imageId", img._id))
            .collect();
            
          return {
            _id: img._id,
            promptId: prompt._id,
            imageUrl: img.imageUrl,
            voteCount: votes.length,
          };
        });
      })
    ).then(results => results.flat());
    
    // Check if current player has voted
    const hasVoted = round && currentPlayer
      ? !!(await ctx.db
          .query("votes")
          .withIndex("by_round_and_voter", (q) =>
            q.eq("roundId", round._id).eq("voterId", currentPlayer._id)
          )
          .unique())
      : false;
      
    // Get current player's prompt
    const myPrompt = round && currentPlayer
      ? await ctx.db
          .query("prompts")
          .withIndex("by_round_and_player", (q) =>
            q.eq("roundId", round._id).eq("playerId", currentPlayer._id)
          )
          .unique()
      : null;
    
    return {
      room: {
        status: room.status,
        currentRound: room.currentRound,
        totalRounds: room.settings.roundsPerGame,
      },
      round,
      players: playersWithInfo,
      prompts,
      images: await Promise.all(images),
      hasVoted,
      myPrompt: myPrompt?.text,
    };
  },
});
```

---

## Feature 3: AI Image Generation

### Step 1: Image Generation Action

Add to `convex/game.ts`:

```typescript
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Generate images for all prompts
export const generateImages = internalAction({
  args: {
    roundId: v.id("rounds"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const round = await ctx.runQuery(internal.game.getRound, { roundId: args.roundId });
    if (!round) return null;
    
    const prompts = await ctx.runQuery(internal.game.getPrompts, { roundId: args.roundId });
    const questionCard = await ctx.runQuery(internal.game.getQuestionCard, { 
      cardId: round.questionCardId 
    });
    
    // Generate images in parallel
    const imageGenerations = prompts.map(async (prompt) => {
      try {
        // Combine question and prompt for better context
        const fullPrompt = `${questionCard.text} ${prompt.text}`;
        
        const response = await openai.images.generate({
          model: "dall-e-3",
          prompt: fullPrompt,
          n: 1,
          size: "1024x1024",
          quality: "standard",
          style: "vivid",
        });
        
        const imageUrl = response.data[0].url;
        if (!imageUrl) throw new Error("No image URL returned");
        
        // Store image URL
        await ctx.runMutation(internal.game.storeGeneratedImage, {
          promptId: prompt._id,
          imageUrl,
          metadata: {
            model: "dall-e-3",
            revisedPrompt: response.data[0].revised_prompt,
          },
        });
      } catch (error) {
        console.error(`Failed to generate image for prompt ${prompt._id}:`, error);
        
        // Store error
        await ctx.runMutation(internal.game.storeImageError, {
          promptId: prompt._id,
          error: error instanceof Error ? error.message : "Unknown error",
        });
      }
    });
    
    await Promise.all(imageGenerations);
    return null;
  },
});

// Store generated image
export const storeGeneratedImage = internalMutation({
  args: {
    promptId: v.id("prompts"),
    imageUrl: v.string(),
    metadata: v.optional(v.object({
      model: v.string(),
      revisedPrompt: v.optional(v.string()),
      seed: v.optional(v.number()),
    })),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.insert("generatedImages", {
      promptId: args.promptId,
      imageUrl: args.imageUrl,
      metadata: args.metadata,
      generatedAt: Date.now(),
    });
    return null;
  },
});

// Store image generation error
export const storeImageError = internalMutation({
  args: {
    promptId: v.id("prompts"),
    error: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.insert("generatedImages", {
      promptId: args.promptId,
      imageUrl: "/placeholder.svg", // Fallback image
      error: args.error,
      generatedAt: Date.now(),
    });
    return null;
  },
});

// Helper queries for action
export const getRound = internalQuery({
  args: { roundId: v.id("rounds") },
  returns: v.union(v.null(), v.object({
    _id: v.id("rounds"),
    questionCardId: v.id("questionCards"),
  })),
  handler: async (ctx, args) => {
    return await ctx.db.get(args.roundId);
  },
});

export const getPrompts = internalQuery({
  args: { roundId: v.id("rounds") },
  returns: v.array(v.object({
    _id: v.id("prompts"),
    text: v.string(),
  })),
  handler: async (ctx, args) => {
    return await ctx.db
      .query("prompts")
      .withIndex("by_round", (q) => q.eq("roundId", args.roundId))
      .collect();
  },
});

export const getQuestionCard = internalQuery({
  args: { cardId: v.id("questionCards") },
  returns: v.object({
    text: v.string(),
  }),
  handler: async (ctx, args) => {
    const card = await ctx.db.get(args.cardId);
    if (!card) throw new Error("Question card not found");
    return { text: card.text };
  },
});
```

### Step 2: Voting System

Add voting functions to `convex/game.ts`:

```typescript
// Submit a vote
export const submitVote = mutation({
  args: {
    roomId: v.id("rooms"),
    imageId: v.id("generatedImages"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");
    
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
    if (!user) throw new Error("User not found");
    
    // Get player
    const player = await ctx.db
      .query("players")
      .withIndex("by_room_and_user", (q) =>
        q.eq("roomId", args.roomId).eq("userId", user._id)
      )
      .unique();
    if (!player) throw new Error("Player not in room");
    
    // Get current round
    const room = await ctx.db.get(args.roomId);
    if (!room || !room.currentRound) {
      throw new Error("No active round");
    }
    
    const round = await ctx.db
      .query("rounds")
      .withIndex("by_room_and_number", (q) =>
        q.eq("roomId", args.roomId).eq("roundNumber", room.currentRound)
      )
      .unique();
      
    if (!round || round.status !== "voting") {
      throw new Error("Not in voting phase");
    }
    
    // Check if already voted
    const existingVote = await ctx.db
      .query("votes")
      .withIndex("by_round_and_voter", (q) =>
        q.eq("roundId", round._id).eq("voterId", player._id)
      )
      .unique();
      
    if (existingVote) {
      // Update vote
      await ctx.db.patch(existingVote._id, {
        imageId: args.imageId,
        submittedAt: Date.now(),
      });
    } else {
      // Create new vote
      await ctx.db.insert("votes", {
        roundId: round._id,
        voterId: player._id,
        imageId: args.imageId,
        submittedAt: Date.now(),
      });
    }
    
    return null;
  },
});

// Calculate scores after voting
export const calculateScores = internalMutation({
  args: {
    roundId: v.id("rounds"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const round = await ctx.db.get(args.roundId);
    if (!round) return null;
    
    // Get all votes for this round
    const votes = await ctx.db
      .query("votes")
      .withIndex("by_round", (q) => q.eq("roundId", args.roundId))
      .collect();
    
    // Count votes per image
    const voteCounts = new Map<string, number>();
    for (const vote of votes) {
      const count = voteCounts.get(vote.imageId) || 0;
      voteCounts.set(vote.imageId, count + 1);
    }
    
    // Find winning image(s)
    const maxVotes = Math.max(...voteCounts.values(), 0);
    const winningImages = Array.from(voteCounts.entries())
      .filter(([_, count]) => count === maxVotes)
      .map(([imageId]) => imageId);
    
    // Award points
    for (const imageId of winningImages) {
      const image = await ctx.db.get(imageId as Id<"generatedImages">);
      if (!image) continue;
      
      const prompt = await ctx.db.get(image.promptId);
      if (!prompt) continue;
      
      const player = await ctx.db.get(prompt.playerId);
      if (!player) continue;
      
      // Award 100 points divided by number of winners
      const points = Math.floor(100 / winningImages.length);
      await ctx.db.patch(player._id, {
        score: player.score + points,
      });
    }
    
    // Award participation points to voters
    for (const vote of votes) {
      await ctx.db.patch(vote.voterId, {
        score: (await ctx.db.get(vote.voterId))!.score + 10,
      });
    }
    
    return null;
  },
});
```

---

## Feature 4: Real-time Updates & Presence

### Step 1: Presence System

Update `convex/schema.ts`:

```typescript
// Add presence table
presence: defineTable({
  userId: v.id("users"),
  roomId: v.optional(v.id("rooms")),
  status: v.union(
    v.literal("online"),
    v.literal("idle"),
    v.literal("offline")
  ),
  lastPing: v.number(),
  currentPage: v.optional(v.string()),
})
  .index("by_user", ["userId"])
  .index("by_room", ["roomId"])
  .index("by_status", ["status"]),
```

Create `convex/presence.ts`:

```typescript
import { mutation, query, internalMutation } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";

// Update user presence
export const updatePresence = mutation({
  args: {
    roomId: v.optional(v.id("rooms")),
    currentPage: v.optional(v.string()),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;
    
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
    if (!user) return null;
    
    const existing = await ctx.db
      .query("presence")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .unique();
      
    if (existing) {
      await ctx.db.patch(existing._id, {
        roomId: args.roomId,
        status: "online",
        lastPing: Date.now(),
        currentPage: args.currentPage,
      });
    } else {
      await ctx.db.insert("presence", {
        userId: user._id,
        roomId: args.roomId,
        status: "online",
        lastPing: Date.now(),
        currentPage: args.currentPage,
      });
    }
    
    // Update player status if in room
    if (args.roomId) {
      const player = await ctx.db
        .query("players")
        .withIndex("by_room_and_user", (q) =>
          q.eq("roomId", args.roomId).eq("userId", user._id)
        )
        .unique();
        
      if (player && player.status === "disconnected") {
        await ctx.db.patch(player._id, {
          status: "connected",
          lastSeenAt: Date.now(),
        });
      }
    }
    
    return null;
  },
});

// Get online users in room
export const getRoomPresence = query({
  args: {
    roomId: v.id("rooms"),
  },
  returns: v.array(v.object({
    userId: v.id("users"),
    username: v.string(),
    status: v.string(),
    lastSeen: v.number(),
  })),
  handler: async (ctx, args) => {
    const presences = await ctx.db
      .query("presence")
      .withIndex("by_room", (q) => q.eq("roomId", args.roomId))
      .filter((q) => 
        q.gte(q.field("lastPing"), Date.now() - 30000) // Active in last 30 seconds
      )
      .collect();
      
    return Promise.all(
      presences.map(async (presence) => {
        const user = await ctx.db.get(presence.userId);
        return {
          userId: presence.userId,
          username: user?.username ?? "Unknown",
          status: presence.status,
          lastSeen: presence.lastPing,
        };
      })
    );
  },
});

// Clean up stale presence
export const cleanupPresence = internalMutation({
  args: {},
  returns: v.null(),
  handler: async (ctx) => {
    const staleTime = Date.now() - 60000; // 1 minute
    
    const stalePresences = await ctx.db
      .query("presence")
      .filter((q) => q.lt(q.field("lastPing"), staleTime))
      .collect();
      
    for (const presence of stalePresences) {
      if (presence.status !== "offline") {
        await ctx.db.patch(presence._id, {
          status: "offline",
        });
        
        // Update player status if in room
        if (presence.roomId) {
          const player = await ctx.db
            .query("players")
            .withIndex("by_room_and_user", (q) =>
              q.eq("roomId", presence.roomId).eq("userId", presence.userId)
            )
            .unique();
            
          if (player && player.status === "connected") {
            await ctx.db.patch(player._id, {
              status: "disconnected",
            });
          }
        }
      }
    }
    
    return null;
  },
});
```

### Step 2: Setup Cron for Presence Cleanup

Create `convex/crons.ts`:

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Clean up stale presence every minute
crons.interval(
  "cleanup presence",
  { minutes: 1 },
  internal.presence.cleanupPresence,
  {}
);

export default crons;
```

### Step 3: Frontend Presence Hook

Create `src/hooks/usePresence.ts`:

```typescript
import { useEffect } from "react";
import { useMutation } from "convex/react";
import { api } from "../convex/_generated/api";
import { Id } from "../convex/_generated/dataModel";

export function usePresence(roomId?: Id<"rooms">) {
  const updatePresence = useMutation(api.presence.updatePresence);
  
  useEffect(() => {
    // Initial ping
    updatePresence({ roomId, currentPage: window.location.pathname });
    
    // Set up interval for regular pings
    const interval = setInterval(() => {
      updatePresence({ roomId, currentPage: window.location.pathname });
    }, 20000); // Every 20 seconds
    
    // Handle visibility change
    const handleVisibilityChange = () => {
      if (!document.hidden) {
        updatePresence({ roomId, currentPage: window.location.pathname });
      }
    };
    
    document.addEventListener("visibilitychange", handleVisibilityChange);
    
    return () => {
      clearInterval(interval);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [roomId, updatePresence]);
}
```

---

## Feature 5: Dashboard & Statistics

### Step 1: Statistics Schema

Update `convex/schema.ts`:

```typescript
// Add statistics tables
gameStats: defineTable({
  roomId: v.id("rooms"),
  winnerId: v.id("users"),
  totalPlayers: v.number(),
  totalRounds: v.number(),
  duration: v.number(), // in milliseconds
  topScore: v.number(),
  completedAt: v.number(),
})
  .index("by_winner", ["winnerId"])
  .index("by_completed", ["completedAt"]),

userStats: defineTable({
  userId: v.id("users"),
  totalGamesPlayed: v.number(),
  totalGamesWon: v.number(),
  totalScore: v.number(),
  bestScore: v.number(),
  totalPrompts: v.number(),
  totalVotes: v.number(),
  favoriteCategory: v.optional(v.string()),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_total_score", ["totalScore"]),
```

### Step 2: Statistics Functions

Create `convex/stats.ts`:

```typescript
import { query, internalMutation } from "./_generated/server";
import { v } from "convex/values";

// Update user statistics after game ends
export const updateUserStats = internalMutation({
  args: {
    roomId: v.id("rooms"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const room = await ctx.db.get(args.roomId);
    if (!room) return null;
    
    // Get all players
    const players = await ctx.db
      .query("players")
      .withIndex("by_room", (q) => q.eq("roomId", args.roomId))
      .collect();
    
    // Find winner
    const winner = players.reduce((prev, current) => 
      prev.score > current.score ? prev : current
    );
    
    // Create game stats
    await ctx.db.insert("gameStats", {
      roomId: args.roomId,
      winnerId: winner.userId,
      totalPlayers: players.length,
      totalRounds: room.settings.roundsPerGame,
      duration: room.finishedAt! - room.startedAt!,
      topScore: winner.score,
      completedAt: Date.now(),
    });
    
    // Update each player's stats
    for (const player of players) {
      const existingStats = await ctx.db
        .query("userStats")
        .withIndex("by_user", (q) => q.eq("userId", player.userId))
        .unique();
        
      const prompts = await ctx.db
        .query("prompts")
        .filter((q) => q.eq(q.field("playerId"), player._id))
        .collect();
        
      const votes = await ctx.db
        .query("votes")
        .filter((q) => q.eq(q.field("voterId"), player._id))
        .collect();
      
      if (existingStats) {
        await ctx.db.patch(existingStats._id, {
          totalGamesPlayed: existingStats.totalGamesPlayed + 1,
          totalGamesWon: existingStats.totalGamesWon + (player._id === winner._id ? 1 : 0),
          totalScore: existingStats.totalScore + player.score,
          bestScore: Math.max(existingStats.bestScore, player.score),
          totalPrompts: existingStats.totalPrompts + prompts.length,
          totalVotes: existingStats.totalVotes + votes.length,
          updatedAt: Date.now(),
        });
      } else {
        await ctx.db.insert("userStats", {
          userId: player.userId,
          totalGamesPlayed: 1,
          totalGamesWon: player._id === winner._id ? 1 : 0,
          totalScore: player.score,
          bestScore: player.score,
          totalPrompts: prompts.length,
          totalVotes: votes.length,
          updatedAt: Date.now(),
        });
      }
      
      // Update user's main stats
      const user = await ctx.db.get(player.userId);
      if (user) {
        await ctx.db.patch(user._id, {
          gamesPlayed: (user.gamesPlayed ?? 0) + 1,
          gamesWon: (user.gamesWon ?? 0) + (player._id === winner._id ? 1 : 0),
          totalScore: (user.totalScore ?? 0) + player.score,
        });
      }
    }
    
    return null;
  },
});

// Get user dashboard data
export const getDashboardData = query({
  args: {},
  returns: v.union(
    v.null(),
    v.object({
      user: v.object({
        username: v.string(),
        displayName: v.string(),
        gamesPlayed: v.number(),
        gamesWon: v.number(),
        winRate: v.number(),
        totalScore: v.number(),
      }),
      recentGames: v.array(v.object({
        _id: v.id("gameStats"),
        roomName: v.string(),
        position: v.number(),
        score: v.number(),
        totalPlayers: v.number(),
        completedAt: v.number(),
      })),
      leaderboard: v.array(v.object({
        rank: v.number(),
        username: v.string(),
        totalScore: v.number(),
        gamesWon: v.number(),
      })),
    })
  ),
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;
    
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
    if (!user) return null;
    
    // Get user stats
    const stats = await ctx.db
      .query("userStats")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .unique();
    
    // Get recent games
    const recentGames = await ctx.db
      .query("gameStats")
      .withIndex("by_completed")
      .order("desc")
      .take(10);
      
    const userRecentGames = await Promise.all(
      recentGames
        .filter(game => game.winnerId === user._id) // Filter games user participated in
        .slice(0, 5)
        .map(async (game) => {
          const room = await ctx.db.get(game.roomId);
          const players = await ctx.db
            .query("players")
            .withIndex("by_room", (q) => q.eq("roomId", game.roomId))
            .collect();
            
          const sortedPlayers = players.sort((a, b) => b.score - a.score);
          const userPlayer = sortedPlayers.find(p => p.userId === user._id);
          const position = userPlayer 
            ? sortedPlayers.indexOf(userPlayer) + 1
            : sortedPlayers.length;
          
          return {
            _id: game._id,
            roomName: room?.name ?? "Unknown",
            position,
            score: userPlayer?.score ?? 0,
            totalPlayers: game.totalPlayers,
            completedAt: game.completedAt,
          };
        })
    );
    
    // Get leaderboard
    const topUsers = await ctx.db
      .query("userStats")
      .withIndex("by_total_score")
      .order("desc")
      .take(10);
      
    const leaderboard = await Promise.all(
      topUsers.map(async (stat, index) => {
        const user = await ctx.db.get(stat.userId);
        return {
          rank: index + 1,
          username: user?.username ?? "Unknown",
          totalScore: stat.totalScore,
          gamesWon: stat.totalGamesWon,
        };
      })
    );
    
    return {
      user: {
        username: user.username ?? "Unknown",
        displayName: user.displayName ?? user.username ?? "Unknown",
        gamesPlayed: stats?.totalGamesPlayed ?? 0,
        gamesWon: stats?.totalGamesWon ?? 0,
        winRate: stats && stats.totalGamesPlayed > 0 
          ? (stats.totalGamesWon / stats.totalGamesPlayed) * 100 
          : 0,
        totalScore: stats?.totalScore ?? 0,
      },
      recentGames: userRecentGames,
      leaderboard,
    };
  },
});
```

---

## Testing & Debugging Guide

### Using Convex MCP Tools

Throughout development, use these tools to debug and test:

```bash
# Check deployment status
mcp_convex_status --projectDir .

# View table data
mcp_convex_data --deploymentSelector dev --tableName users --order asc

# List all tables and schemas
mcp_convex_tables --deploymentSelector dev

# Run a function directly
mcp_convex_run --deploymentSelector dev --functionName "rooms:createRoom" --args '{"name":"Test Room"}'

# Check environment variables
mcp_convex_envList --deploymentSelector dev
```

### Testing Authentication Flow

1. Test sign-up:
```typescript
// In browser console
await convex.mutation(api.auth.signIn, {
  provider: "password",
  params: {
    email: "test@example.com",
    password: "testpass123",
    flow: "signUp"
  }
});
```

2. Test current user:
```typescript
const user = await convex.query(api.users.getCurrentUser);
console.log(user);
```

### Testing Game Flow

1. Create and populate test data:
```typescript
// Create test question cards
await convex.mutation(api.admin.seedQuestionCards, {
  cards: [
    { text: "Draw a superhero who", category: "Creative" },
    { text: "Design a vehicle that", category: "Technical" },
    { text: "Imagine a creature that", category: "Fantasy" },
  ]
});
```

2. Simulate game progression:
```typescript
// Create room
const { roomId, code } = await convex.mutation(api.rooms.createRoom, {
  name: "Test Game"
});

// Join with other users
await convex.mutation(api.rooms.joinRoom, { code });

// Start game
await convex.mutation(api.rooms.startGame, { roomId });

// Submit prompts
await convex.mutation(api.game.submitPrompt, {
  roomId,
  prompt: "flies through space"
});

// Vote
await convex.mutation(api.game.submitVote, {
  roomId,
  imageId: "..."
});
```

---

## Deployment Checklist

### Development Environment
- [ ] Run `npx convex dev` to start development server
- [ ] Verify all environment variables are set
- [ ] Test authentication flow end-to-end
- [ ] Test room creation and joining
- [ ] Test complete game flow
- [ ] Verify real-time updates work
- [ ] Check presence system updates

### Production Deployment
- [ ] Set production environment variables
- [ ] Run `npx convex deploy --prod`
- [ ] Update frontend to use production URL
- [ ] Test all critical paths
- [ ] Monitor logs for errors
- [ ] Set up error alerting

### Performance Optimization
- [ ] Enable database indexes for frequent queries
- [ ] Optimize image generation batch size
- [ ] Implement caching for static data
- [ ] Set up CDN for generated images
- [ ] Monitor and optimize query performance

---

## Common Issues & Solutions

### Issue: Authentication not working
**Solution:** 
- Verify SITE_URL is set correctly
- Check JWT_PRIVATE_KEY is configured
- Ensure ConvexAuthProvider wraps app

### Issue: Real-time updates not reflecting
**Solution:**
- Check WebSocket connection
- Verify subscription queries are correct
- Ensure presence updates are running

### Issue: Image generation fails
**Solution:**
- Verify OPENAI_API_KEY is valid
- Check API rate limits
- Implement retry logic
- Provide fallback images

### Issue: Game state inconsistencies
**Solution:**
- Use transactions for atomic updates
- Implement proper error handling
- Add validation at each phase transition
- Use scheduled functions for time-based events

---

## Next Steps

After completing all features:

1. **Polish UI/UX**
   - Add loading states
   - Implement error boundaries
   - Add animations and transitions
   - Optimize mobile experience

2. **Add Advanced Features**
   - Private rooms with passwords
   - Spectator mode
   - Tournament system
   - Achievement system
   - Social features (friends, invites)

3. **Performance Optimization**
   - Implement image caching
   - Optimize bundle size
   - Add service worker for offline support
   - Implement lazy loading

4. **Monitoring & Analytics**
   - Set up error tracking (Sentry)
   - Add analytics (Mixpanel/Amplitude)
   - Monitor performance metrics
   - Track user engagement

This completes the comprehensive implementation guide for the Visionairy app's Convex backend. Each feature has been designed as a vertical slice to ensure functionality at every step.
